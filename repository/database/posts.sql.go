// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: posts.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getFiveRandomPosts = `-- name: GetFiveRandomPosts :many
SELECT
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
FROM
    posts
WHERE
    released_at IS NOT NULL AND draft = false AND posts.id != $1
ORDER BY
    random()
limit 5
`

type GetFiveRandomPostsRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetFiveRandomPosts(ctx context.Context, id uuid.UUID) ([]GetFiveRandomPostsRow, error) {
	rows, err := q.db.Query(ctx, getFiveRandomPosts, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFiveRandomPostsRow
	for rows.Next() {
		var i GetFiveRandomPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPosts = `-- name: GetLatestPosts :many
SELECT
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
FROM
    posts
WHERE
    released_at IS NOT NULL AND draft = false
ORDER BY
    released_at DESC
`

type GetLatestPostsRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetLatestPosts(ctx context.Context) ([]GetLatestPostsRow, error) {
	rows, err := q.db.Query(ctx, getLatestPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPostsRow
	for rows.Next() {
		var i GetLatestPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostBySlug = `-- name: GetPostBySlug :one
SELECT
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
FROM
    posts
WHERE
    slug = $1
`

type GetPostBySlugRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetPostBySlug(ctx context.Context, slug string) (GetPostBySlugRow, error) {
	row := q.db.QueryRow(ctx, getPostBySlug, slug)
	var i GetPostBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.HeaderTitle,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
insert into posts (id, created_at, updated_at, title, header_title, filename, slug, excerpt, draft, released_at, read_time)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning id
`

type InsertPostParams struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertPost,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.HeaderTitle,
		arg.Filename,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const queryAllFilenames = `-- name: QueryAllFilenames :many
select filename from posts
`

func (q *Queries) QueryAllFilenames(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, queryAllFilenames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var filename string
		if err := rows.Scan(&filename); err != nil {
			return nil, err
		}
		items = append(items, filename)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryAllPosts = `-- name: QueryAllPosts :many
SELECT
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time,
    (select count(id) from posts) as total_posts_count
FROM
    posts
LIMIT
    7
OFFSET
    $1
`

type QueryAllPostsRow struct {
	ID              uuid.UUID
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	Title           string
	HeaderTitle     sql.NullString
	Filename        string
	Slug            string
	Excerpt         string
	Draft           bool
	ReleasedAt      pgtype.Timestamp
	ReadTime        sql.NullInt32
	TotalPostsCount int64
}

func (q *Queries) QueryAllPosts(ctx context.Context, offset int32) ([]QueryAllPostsRow, error) {
	rows, err := q.db.Query(ctx, queryAllPosts, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAllPostsRow
	for rows.Next() {
		var i QueryAllPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.TotalPostsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPostByID = `-- name: QueryPostByID :one
select id, created_at, updated_at, title, filename, slug, excerpt, draft, released_at, read_time, header_title from posts where id = $1
`

func (q *Queries) QueryPostByID(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, queryPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}

const queryPosts = `-- name: QueryPosts :many
select posts.id, posts.created_at, posts.updated_at, posts.title, posts.filename, posts.slug, posts.excerpt, posts.draft, posts.released_at, posts.read_time, posts.header_title from posts
`

func (q *Queries) QueryPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, queryPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.HeaderTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
update posts
    set updated_at = $1, title = $2, header_title = $3, slug = $4, excerpt = $5, draft = $6, released_at = $7, read_time = $8
where id = $9
returning id, created_at, updated_at, title, filename, slug, excerpt, draft, released_at, read_time, header_title
`

type UpdatePostParams struct {
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
	ID          uuid.UUID
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.UpdatedAt,
		arg.Title,
		arg.HeaderTitle,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}
