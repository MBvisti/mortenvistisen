// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: posts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getLatestPosts = `-- name: GetLatestPosts :many
SELECT
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time,
    array_agg(tags)::uuid[] AS tag_ids
FROM
    posts
INNER JOIN
    posts_tags ON posts.id = posts_tags.post_id
RIGHT JOIN
    tags ON tags.id = posts_tags.tag_id
WHERE
    released_at IS NOT NULL && draft = false
ORDER BY
    released_at DESC
LIMIT
    5
`

type GetLatestPostsRow struct {
	ID         int32
	CreatedAt  time.Time
	UpdatedAt  time.Time
	Title      string
	Filename   string
	Slug       string
	Excerpt    string
	Draft      bool
	ReleasedAt sql.NullTime
	ReadTime   sql.NullInt32
	TagIds     []uuid.UUID
}

func (q *Queries) GetLatestPosts(ctx context.Context) ([]GetLatestPostsRow, error) {
	rows, err := q.db.Query(ctx, getLatestPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPostsRow
	for rows.Next() {
		var i GetLatestPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.TagIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
