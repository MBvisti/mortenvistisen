// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: posts.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getFiveRandomPosts = `-- name: GetFiveRandomPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
from posts
where released_at is not null and draft = false and posts.id != $1
order by random()
limit 5
`

type GetFiveRandomPostsRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetFiveRandomPosts(ctx context.Context, id uuid.UUID) ([]GetFiveRandomPostsRow, error) {
	rows, err := q.db.Query(ctx, getFiveRandomPosts, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFiveRandomPostsRow
	for rows.Next() {
		var i GetFiveRandomPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPosts = `-- name: GetLatestPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
from posts
where released_at is not null and draft = false
order by released_at desc
`

type GetLatestPostsRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetLatestPosts(ctx context.Context) ([]GetLatestPostsRow, error) {
	rows, err := q.db.Query(ctx, getLatestPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPostsRow
	for rows.Next() {
		var i GetLatestPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostBySlug = `-- name: GetPostBySlug :one
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time
from posts
where slug = $1
`

type GetPostBySlugRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) GetPostBySlug(ctx context.Context, slug string) (GetPostBySlugRow, error) {
	row := q.db.QueryRow(ctx, getPostBySlug, slug)
	var i GetPostBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.HeaderTitle,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
insert into posts (id, created_at, updated_at, title, header_title, filename, slug, excerpt, draft, released_at, read_time)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning id
`

type InsertPostParams struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertPost,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.HeaderTitle,
		arg.Filename,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const queryAllFilenames = `-- name: QueryAllFilenames :many
select filename
from posts
`

func (q *Queries) QueryAllFilenames(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, queryAllFilenames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var filename string
		if err := rows.Scan(&filename); err != nil {
			return nil, err
		}
		items = append(items, filename)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryAllPosts = `-- name: QueryAllPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.title,
    posts.header_title,
    posts.filename,
    posts.slug,
    posts.excerpt,
    posts.draft,
    posts.released_at,
    posts.read_time,
    (select count(id) from posts) as total_posts_count
from posts
limit 7
offset $1
`

type QueryAllPostsRow struct {
	ID              uuid.UUID
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	Title           string
	HeaderTitle     sql.NullString
	Filename        string
	Slug            string
	Excerpt         string
	Draft           bool
	ReleasedAt      pgtype.Timestamp
	ReadTime        sql.NullInt32
	TotalPostsCount int64
}

func (q *Queries) QueryAllPosts(ctx context.Context, offset int32) ([]QueryAllPostsRow, error) {
	rows, err := q.db.Query(ctx, queryAllPosts, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAllPostsRow
	for rows.Next() {
		var i QueryAllPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.HeaderTitle,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.TotalPostsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPostByID = `-- name: QueryPostByID :one
select id, created_at, updated_at, title, filename, slug, excerpt, draft, released_at, read_time, header_title
from posts
where id = $1
`

func (q *Queries) QueryPostByID(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, queryPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}

const queryPostBySlug = `-- name: QueryPostBySlug :one
select id, created_at, updated_at, title, filename, slug, excerpt, draft, released_at, read_time, header_title
from posts
where slug = $1
`

func (q *Queries) QueryPostBySlug(ctx context.Context, slug string) (Post, error) {
	row := q.db.QueryRow(ctx, queryPostBySlug, slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}

const queryPosts = `-- name: QueryPosts :many
select posts.id, posts.created_at, posts.updated_at, posts.title, posts.filename, posts.slug, posts.excerpt, posts.draft, posts.released_at, posts.read_time, posts.header_title, array_agg(tags.*) as tags
from posts
join posts_tags on posts_tags.post_id = posts.id
join tags on tags.id = posts_tags.tag_id
order by posts.created_at
limit coalesce($2::int, null)
offset coalesce($1::int, 0)
`

type QueryPostsParams struct {
	Offset sql.NullInt32
	Limit  sql.NullInt32
}

type QueryPostsRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
	HeaderTitle sql.NullString
	Tags        interface{}
}

func (q *Queries) QueryPosts(ctx context.Context, arg QueryPostsParams) ([]QueryPostsRow, error) {
	rows, err := q.db.Query(ctx, queryPosts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryPostsRow
	for rows.Next() {
		var i QueryPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.HeaderTitle,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPostsCount = `-- name: QueryPostsCount :one
select count(id)
from posts
`

func (q *Queries) QueryPostsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, queryPostsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const queryPostsInPages = `-- name: QueryPostsInPages :many
select posts.id, posts.created_at, posts.updated_at, posts.title, posts.filename, posts.slug, posts.excerpt, posts.draft, posts.released_at, posts.read_time, posts.header_title
from posts
limit $1
offset $2
`

type QueryPostsInPagesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) QueryPostsInPages(ctx context.Context, arg QueryPostsInPagesParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, queryPostsInPages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleasedAt,
			&i.ReadTime,
			&i.HeaderTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
update posts
    set updated_at = $1, title = $2, header_title = $3, slug = $4, excerpt = $5, draft = $6, released_at = $7, read_time = $8
where id = $9
returning id, created_at, updated_at, title, filename, slug, excerpt, draft, released_at, read_time, header_title
`

type UpdatePostParams struct {
	UpdatedAt   pgtype.Timestamp
	Title       string
	HeaderTitle sql.NullString
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
	ID          uuid.UUID
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.UpdatedAt,
		arg.Title,
		arg.HeaderTitle,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleasedAt,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}
