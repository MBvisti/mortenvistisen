// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: newsletters.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsletters = `-- name: CountNewsletters :one
select count(id)
from newsletters
where released = coalesce($1::bool, null)
`

func (q *Queries) CountNewsletters(ctx context.Context, released pgtype.Bool) (int64, error) {
	row := q.db.QueryRow(ctx, countNewsletters, released)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertNewsletter = `-- name: InsertNewsletter :one
insert into newsletters
	(id, created_at, updated_at, title, edition, released, released_at, body, associated_article_id)
values 
	($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, created_at, updated_at, title, edition, released, released_at, body, associated_article_id
`

type InsertNewsletterParams struct {
	ID                  uuid.UUID
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	Title               string
	Edition             sql.NullInt32
	Released            pgtype.Bool
	ReleasedAt          pgtype.Timestamptz
	Body                []byte
	AssociatedArticleID uuid.UUID
}

func (q *Queries) InsertNewsletter(ctx context.Context, arg InsertNewsletterParams) (Newsletter, error) {
	row := q.db.QueryRow(ctx, insertNewsletter,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.Edition,
		arg.Released,
		arg.ReleasedAt,
		arg.Body,
		arg.AssociatedArticleID,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Edition,
		&i.Released,
		&i.ReleasedAt,
		&i.Body,
		&i.AssociatedArticleID,
	)
	return i, err
}

const queryNewsletterByID = `-- name: QueryNewsletterByID :one
select id, created_at, updated_at, title, edition, released, released_at, body, associated_article_id
from newsletters
where id = $1
`

func (q *Queries) QueryNewsletterByID(ctx context.Context, id uuid.UUID) (Newsletter, error) {
	row := q.db.QueryRow(ctx, queryNewsletterByID, id)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Edition,
		&i.Released,
		&i.ReleasedAt,
		&i.Body,
		&i.AssociatedArticleID,
	)
	return i, err
}

const queryNewsletterInPages = `-- name: QueryNewsletterInPages :many
select newsletters.id, newsletters.created_at, newsletters.updated_at, newsletters.title, newsletters.edition, newsletters.released, newsletters.released_at, newsletters.body, newsletters.associated_article_id
from newsletters
limit 7
offset $1
`

func (q *Queries) QueryNewsletterInPages(ctx context.Context, offset int32) ([]Newsletter, error) {
	rows, err := q.db.Query(ctx, queryNewsletterInPages, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Edition,
			&i.Released,
			&i.ReleasedAt,
			&i.Body,
			&i.AssociatedArticleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewsletters = `-- name: QueryNewsletters :many
select
    newsletters.id as newsletter_id,
    newsletters.created_at as newsletter_created_at,
    newsletters.updated_at as newsletter_updated_at,
    newsletters.title as newsletter_title,
    newsletters.edition as newsletter_edition,
    newsletters.released as newsletter_released,
    newsletters.released_at as newsletter_released_at,
    newsletters.body as newsletter_body,
    newsletters.associated_article_id as newsletter_associated_article_id,
    posts.id as post_id,
    posts.created_at as post_created_at,
    posts.updated_at as post_updated_at,
    posts.title as post_title,
    posts.header_title as post_header_title,
    posts.filename as post_filename,
    posts.slug as post_slug,
    posts.excerpt as post_excerpt,
    posts.draft as post_draft,
    posts.released_at as post_released_at,
    posts.read_time as post_read_time
from newsletters
join posts on posts.id = newsletters.associated_article_id
where
    (
        newsletters.released = $1::bool
        or $1::bool is null
    )
limit coalesce($3::int, null)
offset coalesce($2::int, 0)
`

type QueryNewslettersParams struct {
	IsReleased pgtype.Bool
	Offset     sql.NullInt32
	Limit      sql.NullInt32
}

type QueryNewslettersRow struct {
	NewsletterID                  uuid.UUID
	NewsletterCreatedAt           pgtype.Timestamptz
	NewsletterUpdatedAt           pgtype.Timestamptz
	NewsletterTitle               string
	NewsletterEdition             sql.NullInt32
	NewsletterReleased            pgtype.Bool
	NewsletterReleasedAt          pgtype.Timestamptz
	NewsletterBody                []byte
	NewsletterAssociatedArticleID uuid.UUID
	PostID                        uuid.UUID
	PostCreatedAt                 pgtype.Timestamp
	PostUpdatedAt                 pgtype.Timestamp
	PostTitle                     string
	PostHeaderTitle               sql.NullString
	PostFilename                  string
	PostSlug                      string
	PostExcerpt                   string
	PostDraft                     bool
	PostReleasedAt                pgtype.Timestamp
	PostReadTime                  sql.NullInt32
}

func (q *Queries) QueryNewsletters(ctx context.Context, arg QueryNewslettersParams) ([]QueryNewslettersRow, error) {
	rows, err := q.db.Query(ctx, queryNewsletters, arg.IsReleased, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryNewslettersRow
	for rows.Next() {
		var i QueryNewslettersRow
		if err := rows.Scan(
			&i.NewsletterID,
			&i.NewsletterCreatedAt,
			&i.NewsletterUpdatedAt,
			&i.NewsletterTitle,
			&i.NewsletterEdition,
			&i.NewsletterReleased,
			&i.NewsletterReleasedAt,
			&i.NewsletterBody,
			&i.NewsletterAssociatedArticleID,
			&i.PostID,
			&i.PostCreatedAt,
			&i.PostUpdatedAt,
			&i.PostTitle,
			&i.PostHeaderTitle,
			&i.PostFilename,
			&i.PostSlug,
			&i.PostExcerpt,
			&i.PostDraft,
			&i.PostReleasedAt,
			&i.PostReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewslettersCount = `-- name: QueryNewslettersCount :one
select count(id)
from newsletters
`

func (q *Queries) QueryNewslettersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, queryNewslettersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const queryReleasedNewslettersCount = `-- name: QueryReleasedNewslettersCount :one
select count(id) as newsletters_count
from newsletters
where released = true
`

func (q *Queries) QueryReleasedNewslettersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, queryReleasedNewslettersCount)
	var newsletters_count int64
	err := row.Scan(&newsletters_count)
	return newsletters_count, err
}

const updateNewsletter = `-- name: UpdateNewsletter :one
update newsletters
	set updated_at = $1, title = $2, edition = $3, released = $4, released_at = $5, body = $6, associated_article_id = $7
where id = $8
returning id, created_at, updated_at, title, edition, released, released_at, body, associated_article_id
`

type UpdateNewsletterParams struct {
	UpdatedAt           pgtype.Timestamptz
	Title               string
	Edition             sql.NullInt32
	Released            pgtype.Bool
	ReleasedAt          pgtype.Timestamptz
	Body                []byte
	AssociatedArticleID uuid.UUID
	ID                  uuid.UUID
}

func (q *Queries) UpdateNewsletter(ctx context.Context, arg UpdateNewsletterParams) (Newsletter, error) {
	row := q.db.QueryRow(ctx, updateNewsletter,
		arg.UpdatedAt,
		arg.Title,
		arg.Edition,
		arg.Released,
		arg.ReleasedAt,
		arg.Body,
		arg.AssociatedArticleID,
		arg.ID,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Edition,
		&i.Released,
		&i.ReleasedAt,
		&i.Body,
		&i.AssociatedArticleID,
	)
	return i, err
}
