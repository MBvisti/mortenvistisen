// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: newsletter_send_tracking.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteNewsletterEmailSends = `-- name: DeleteNewsletterEmailSends :exec
DELETE FROM newsletter_email_sends 
WHERE newsletter_id = $1
`

func (q *Queries) DeleteNewsletterEmailSends(ctx context.Context, db DBTX, newsletterID uuid.UUID) error {
	_, err := db.Exec(ctx, deleteNewsletterEmailSends, newsletterID)
	return err
}

const getAllNewsletterSendStats = `-- name: GetAllNewsletterSendStats :many
SELECT 
    newsletter_id,
    COUNT(*) as total_emails,
    COUNT(*) FILTER (WHERE status = 'sent') as sent_emails,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_emails,
    COUNT(*) FILTER (WHERE status = 'bounced') as bounced_emails,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_emails,
    ROUND(
        (COUNT(*) FILTER (WHERE status = 'sent')::DECIMAL / COUNT(*)) * 100, 2
    ) as completion_rate
FROM newsletter_email_sends 
GROUP BY newsletter_id
`

type GetAllNewsletterSendStatsRow struct {
	NewsletterID   uuid.UUID
	TotalEmails    int64
	SentEmails     int64
	FailedEmails   int64
	BouncedEmails  int64
	PendingEmails  int64
	CompletionRate pgtype.Numeric
}

func (q *Queries) GetAllNewsletterSendStats(ctx context.Context, db DBTX) ([]GetAllNewsletterSendStatsRow, error) {
	rows, err := db.Query(ctx, getAllNewsletterSendStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllNewsletterSendStatsRow
	for rows.Next() {
		var i GetAllNewsletterSendStatsRow
		if err := rows.Scan(
			&i.NewsletterID,
			&i.TotalEmails,
			&i.SentEmails,
			&i.FailedEmails,
			&i.BouncedEmails,
			&i.PendingEmails,
			&i.CompletionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsletterEmailSendsByNewsletter = `-- name: GetNewsletterEmailSendsByNewsletter :many
SELECT id, newsletter_id, subscriber_id, email_address, status, sent_at, failed_at, error_message, river_job_id, created_at, updated_at FROM newsletter_email_sends 
WHERE newsletter_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetNewsletterEmailSendsByNewsletter(ctx context.Context, db DBTX, newsletterID uuid.UUID) ([]NewsletterEmailSend, error) {
	rows, err := db.Query(ctx, getNewsletterEmailSendsByNewsletter, newsletterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsletterEmailSend
	for rows.Next() {
		var i NewsletterEmailSend
		if err := rows.Scan(
			&i.ID,
			&i.NewsletterID,
			&i.SubscriberID,
			&i.EmailAddress,
			&i.Status,
			&i.SentAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.RiverJobID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsletterSendStats = `-- name: GetNewsletterSendStats :one
SELECT 
    newsletter_id,
    COUNT(*) as total_emails,
    COUNT(*) FILTER (WHERE status = 'sent') as sent_emails,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_emails,
    COUNT(*) FILTER (WHERE status = 'bounced') as bounced_emails,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_emails,
    ROUND(
        (COUNT(*) FILTER (WHERE status = 'sent')::DECIMAL / COUNT(*)) * 100, 2
    ) as completion_rate
FROM newsletter_email_sends 
WHERE newsletter_id = $1
GROUP BY newsletter_id
`

type GetNewsletterSendStatsRow struct {
	NewsletterID   uuid.UUID
	TotalEmails    int64
	SentEmails     int64
	FailedEmails   int64
	BouncedEmails  int64
	PendingEmails  int64
	CompletionRate pgtype.Numeric
}

func (q *Queries) GetNewsletterSendStats(ctx context.Context, db DBTX, newsletterID uuid.UUID) (GetNewsletterSendStatsRow, error) {
	row := db.QueryRow(ctx, getNewsletterSendStats, newsletterID)
	var i GetNewsletterSendStatsRow
	err := row.Scan(
		&i.NewsletterID,
		&i.TotalEmails,
		&i.SentEmails,
		&i.FailedEmails,
		&i.BouncedEmails,
		&i.PendingEmails,
		&i.CompletionRate,
	)
	return i, err
}

const insertNewsletterEmailSend = `-- name: InsertNewsletterEmailSend :one
INSERT INTO newsletter_email_sends (
    newsletter_id, subscriber_id, email_address, status, river_job_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, newsletter_id, subscriber_id, email_address, status, sent_at, failed_at, error_message, river_job_id, created_at, updated_at
`

type InsertNewsletterEmailSendParams struct {
	NewsletterID uuid.UUID
	SubscriberID uuid.UUID
	EmailAddress string
	Status       string
	RiverJobID   sql.NullInt64
}

func (q *Queries) InsertNewsletterEmailSend(ctx context.Context, db DBTX, arg InsertNewsletterEmailSendParams) (NewsletterEmailSend, error) {
	row := db.QueryRow(ctx, insertNewsletterEmailSend,
		arg.NewsletterID,
		arg.SubscriberID,
		arg.EmailAddress,
		arg.Status,
		arg.RiverJobID,
	)
	var i NewsletterEmailSend
	err := row.Scan(
		&i.ID,
		&i.NewsletterID,
		&i.SubscriberID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RiverJobID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNewsletterEmailSendStatus = `-- name: UpdateNewsletterEmailSendStatus :one
UPDATE newsletter_email_sends 
SET 
    status = $3,
    sent_at = CASE WHEN $3 = 'sent' THEN NOW() ELSE sent_at END,
    failed_at = CASE WHEN $3 IN ('failed', 'bounced') THEN NOW() ELSE failed_at END,
    error_message = $4,
    updated_at = NOW()
WHERE newsletter_id = $1 AND subscriber_id = $2
RETURNING id, newsletter_id, subscriber_id, email_address, status, sent_at, failed_at, error_message, river_job_id, created_at, updated_at
`

type UpdateNewsletterEmailSendStatusParams struct {
	NewsletterID uuid.UUID
	SubscriberID uuid.UUID
	Status       string
	ErrorMessage sql.NullString
}

func (q *Queries) UpdateNewsletterEmailSendStatus(ctx context.Context, db DBTX, arg UpdateNewsletterEmailSendStatusParams) (NewsletterEmailSend, error) {
	row := db.QueryRow(ctx, updateNewsletterEmailSendStatus,
		arg.NewsletterID,
		arg.SubscriberID,
		arg.Status,
		arg.ErrorMessage,
	)
	var i NewsletterEmailSend
	err := row.Scan(
		&i.ID,
		&i.NewsletterID,
		&i.SubscriberID,
		&i.EmailAddress,
		&i.Status,
		&i.SentAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RiverJobID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
