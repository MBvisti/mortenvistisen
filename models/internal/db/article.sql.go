// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: article.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeleteArticle(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteArticle, id)
	return err
}

const deleteArticleTags = `-- name: DeleteArticleTags :exec
DELETE FROM posts_tags WHERE post_id = $1
`

func (q *Queries) DeleteArticleTags(ctx context.Context, db DBTX, postID uuid.UUID) error {
	_, err := db.Exec(ctx, deleteArticleTags, postID)
	return err
}

const insertArticle = `-- name: InsertArticle :one
INSERT INTO posts (
    id, created_at, updated_at, title, filename,
    slug, excerpt, draft, released_at, read_time,
	header_title
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id
`

type InsertArticleParams struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleasedAt  pgtype.Timestamp
	ReadTime    sql.NullInt32
	HeaderTitle sql.NullString
}

func (q *Queries) InsertArticle(ctx context.Context, db DBTX, arg InsertArticleParams) (uuid.UUID, error) {
	row := db.QueryRow(ctx, insertArticle,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.Filename,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
		arg.HeaderTitle,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertArticleTag = `-- name: InsertArticleTag :exec
INSERT INTO posts_tags (
    id, post_id, tag_id
) VALUES (
    $1, $2, $3
)
`

type InsertArticleTagParams struct {
	ID     uuid.UUID
	PostID uuid.UUID
	TagID  uuid.UUID
}

func (q *Queries) InsertArticleTag(ctx context.Context, db DBTX, arg InsertArticleTagParams) error {
	_, err := db.Exec(ctx, insertArticleTag, arg.ID, arg.PostID, arg.TagID)
	return err
}

const queryArticleByID = `-- name: QueryArticleByID :one
SELECT 
    p.id, p.created_at, p.updated_at, p.title, p.filename, 
    p.slug, p.excerpt, p.draft, p.released_at as release_date, 
    p.read_time
FROM posts p
WHERE p.id = $1
`

type QueryArticleByIDRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleaseDate pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) QueryArticleByID(ctx context.Context, db DBTX, id uuid.UUID) (QueryArticleByIDRow, error) {
	row := db.QueryRow(ctx, queryArticleByID, id)
	var i QueryArticleByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleaseDate,
		&i.ReadTime,
	)
	return i, err
}

const queryArticleBySlug = `-- name: QueryArticleBySlug :one
SELECT 
    p.id, p.created_at, p.updated_at, p.title, p.filename, 
    p.slug, p.excerpt, p.draft, p.released_at as release_date, 
    p.read_time, p.header_title
FROM posts p
WHERE p.slug = $1
`

type QueryArticleBySlugRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleaseDate pgtype.Timestamp
	ReadTime    sql.NullInt32
	HeaderTitle sql.NullString
}

func (q *Queries) QueryArticleBySlug(ctx context.Context, db DBTX, slug string) (QueryArticleBySlugRow, error) {
	row := db.QueryRow(ctx, queryArticleBySlug, slug)
	var i QueryArticleBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Filename,
		&i.Slug,
		&i.Excerpt,
		&i.Draft,
		&i.ReleaseDate,
		&i.ReadTime,
		&i.HeaderTitle,
	)
	return i, err
}

const queryArticleTags = `-- name: QueryArticleTags :many
SELECT t.id, t.name
FROM tags t
JOIN posts_tags pt ON pt.tag_id = t.id
WHERE pt.post_id = $1
`

func (q *Queries) QueryArticleTags(ctx context.Context, db DBTX, postID uuid.UUID) ([]Tag, error) {
	rows, err := db.Query(ctx, queryArticleTags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryArticles = `-- name: QueryArticles :many
SELECT 
    p.id, p.created_at, p.updated_at, p.title, p.filename, 
    p.slug, p.excerpt, p.draft, p.released_at as release_date, 
    p.read_time
FROM posts p
ORDER BY p.created_at DESC
`

type QueryArticlesRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleaseDate pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) QueryArticles(ctx context.Context, db DBTX) ([]QueryArticlesRow, error) {
	rows, err := db.Query(ctx, queryArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryArticlesRow
	for rows.Next() {
		var i QueryArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleaseDate,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryArticlesCount = `-- name: QueryArticlesCount :one
SELECT COUNT(*) FROM posts
`

func (q *Queries) QueryArticlesCount(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, queryArticlesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const queryArticlesPage = `-- name: QueryArticlesPage :many
SELECT 
    p.id, p.created_at, p.updated_at, p.title, p.filename, 
    p.slug, p.excerpt, p.draft, p.released_at as release_date, 
    p.read_time
FROM posts p
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type QueryArticlesPageParams struct {
	Limit  int32
	Offset int32
}

type QueryArticlesPageRow struct {
	ID          uuid.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	Title       string
	Filename    string
	Slug        string
	Excerpt     string
	Draft       bool
	ReleaseDate pgtype.Timestamp
	ReadTime    sql.NullInt32
}

func (q *Queries) QueryArticlesPage(ctx context.Context, db DBTX, arg QueryArticlesPageParams) ([]QueryArticlesPageRow, error) {
	rows, err := db.Query(ctx, queryArticlesPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryArticlesPageRow
	for rows.Next() {
		var i QueryArticlesPageRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Filename,
			&i.Slug,
			&i.Excerpt,
			&i.Draft,
			&i.ReleaseDate,
			&i.ReadTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE posts
SET 
    updated_at = $2,
    title = $3,
    filename = $4,
    slug = $5,
    excerpt = $6,
    draft = $7,
    released_at = $8,
    read_time = $9
WHERE id = $1
`

type UpdateArticleParams struct {
	ID         uuid.UUID
	UpdatedAt  pgtype.Timestamp
	Title      string
	Filename   string
	Slug       string
	Excerpt    string
	Draft      bool
	ReleasedAt pgtype.Timestamp
	ReadTime   sql.NullInt32
}

func (q *Queries) UpdateArticle(ctx context.Context, db DBTX, arg UpdateArticleParams) error {
	_, err := db.Exec(ctx, updateArticle,
		arg.ID,
		arg.UpdatedAt,
		arg.Title,
		arg.Filename,
		arg.Slug,
		arg.Excerpt,
		arg.Draft,
		arg.ReleasedAt,
		arg.ReadTime,
	)
	return err
}
