// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: newsletters.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsletters = `-- name: CountNewsletters :one
select count(*) from newsletters
`

func (q *Queries) CountNewsletters(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countNewsletters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteNewsletter = `-- name: DeleteNewsletter :exec
delete from newsletters where id=$1
`

func (q *Queries) DeleteNewsletter(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteNewsletter, id)
	return err
}

const insertNewsletter = `-- name: InsertNewsletter :one
insert into
    newsletters (id, created_at, updated_at, title, slug, content)
values
    ($1, $2, $3, $4, $5, $6)
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type InsertNewsletterParams struct {
	ID        uuid.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Title     string
	Slug      sql.NullString
	Content   string
}

func (q *Queries) InsertNewsletter(ctx context.Context, db DBTX, arg InsertNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, insertNewsletter,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.Slug,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const markNewsletterReadyToSend = `-- name: MarkNewsletterReadyToSend :one
update newsletters
    set updated_at=$2, send_status='ready_to_send', total_recipients=$3
where id = $1
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type MarkNewsletterReadyToSendParams struct {
	ID              uuid.UUID
	UpdatedAt       pgtype.Timestamptz
	TotalRecipients int32
}

func (q *Queries) MarkNewsletterReadyToSend(ctx context.Context, db DBTX, arg MarkNewsletterReadyToSendParams) (Newsletter, error) {
	row := db.QueryRow(ctx, markNewsletterReadyToSend, arg.ID, arg.UpdatedAt, arg.TotalRecipients)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const publishNewsletter = `-- name: PublishNewsletter :one
update newsletters
    set updated_at=$2, is_published=$3, released_at=$4
where id = $1
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type PublishNewsletterParams struct {
	ID          uuid.UUID
	UpdatedAt   pgtype.Timestamptz
	IsPublished pgtype.Bool
	ReleasedAt  pgtype.Timestamptz
}

func (q *Queries) PublishNewsletter(ctx context.Context, db DBTX, arg PublishNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, publishNewsletter,
		arg.ID,
		arg.UpdatedAt,
		arg.IsPublished,
		arg.ReleasedAt,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const queryDraftNewsletters = `-- name: QueryDraftNewsletters :many
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where is_published=false order by created_at desc
`

func (q *Queries) QueryDraftNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryDraftNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Slug,
			&i.Content,
			&i.SendStatus,
			&i.TotalRecipients,
			&i.EmailsSent,
			&i.SendingStartedAt,
			&i.SendingCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewsletterByID = `-- name: QueryNewsletterByID :one
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where id=$1
`

func (q *Queries) QueryNewsletterByID(ctx context.Context, db DBTX, id uuid.UUID) (Newsletter, error) {
	row := db.QueryRow(ctx, queryNewsletterByID, id)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const queryNewsletterBySlug = `-- name: QueryNewsletterBySlug :one
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where slug=$1
`

func (q *Queries) QueryNewsletterBySlug(ctx context.Context, db DBTX, slug sql.NullString) (Newsletter, error) {
	row := db.QueryRow(ctx, queryNewsletterBySlug, slug)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const queryNewsletterByTitle = `-- name: QueryNewsletterByTitle :one
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where title=$1
`

func (q *Queries) QueryNewsletterByTitle(ctx context.Context, db DBTX, title string) (Newsletter, error) {
	row := db.QueryRow(ctx, queryNewsletterByTitle, title)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const queryNewsletters = `-- name: QueryNewsletters :many
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters order by created_at desc
`

func (q *Queries) QueryNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Slug,
			&i.Content,
			&i.SendStatus,
			&i.TotalRecipients,
			&i.EmailsSent,
			&i.SendingStartedAt,
			&i.SendingCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewslettersPaginated = `-- name: QueryNewslettersPaginated :many
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters 
order by created_at desc 
limit $1 offset $2
`

type QueryNewslettersPaginatedParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) QueryNewslettersPaginated(ctx context.Context, db DBTX, arg QueryNewslettersPaginatedParams) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryNewslettersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Slug,
			&i.Content,
			&i.SendStatus,
			&i.TotalRecipients,
			&i.EmailsSent,
			&i.SendingStartedAt,
			&i.SendingCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewslettersReadyToSend = `-- name: QueryNewslettersReadyToSend :many
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where send_status='ready_to_send' order by created_at asc
`

func (q *Queries) QueryNewslettersReadyToSend(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryNewslettersReadyToSend)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Slug,
			&i.Content,
			&i.SendStatus,
			&i.TotalRecipients,
			&i.EmailsSent,
			&i.SendingStartedAt,
			&i.SendingCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPublishedNewsletters = `-- name: QueryPublishedNewsletters :many
select id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at from newsletters where is_published=true order by released_at desc
`

func (q *Queries) QueryPublishedNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryPublishedNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Slug,
			&i.Content,
			&i.SendStatus,
			&i.TotalRecipients,
			&i.EmailsSent,
			&i.SendingStartedAt,
			&i.SendingCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNewsletter = `-- name: UpdateNewsletter :one
update newsletters
    set updated_at=$2, title=$3, slug=$4, content=$5, is_published=$6
where id = $1
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type UpdateNewsletterParams struct {
	ID          uuid.UUID
	UpdatedAt   pgtype.Timestamptz
	Title       string
	Slug        sql.NullString
	Content     string
	IsPublished pgtype.Bool
}

func (q *Queries) UpdateNewsletter(ctx context.Context, db DBTX, arg UpdateNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, updateNewsletter,
		arg.ID,
		arg.UpdatedAt,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.IsPublished,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const updateNewsletterContent = `-- name: UpdateNewsletterContent :one
update newsletters
    set updated_at=$2, content=$3
where id = $1
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type UpdateNewsletterContentParams struct {
	ID        uuid.UUID
	UpdatedAt pgtype.Timestamptz
	Content   string
}

func (q *Queries) UpdateNewsletterContent(ctx context.Context, db DBTX, arg UpdateNewsletterContentParams) (Newsletter, error) {
	row := db.QueryRow(ctx, updateNewsletterContent, arg.ID, arg.UpdatedAt, arg.Content)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}

const updateNewsletterSendStatus = `-- name: UpdateNewsletterSendStatus :one
update newsletters
    set updated_at=$2, send_status=$3, sending_started_at=$4, sending_completed_at=$5, emails_sent=$6
where id = $1
returning id, created_at, updated_at, title, is_published, released_at, slug, content, send_status, total_recipients, emails_sent, sending_started_at, sending_completed_at
`

type UpdateNewsletterSendStatusParams struct {
	ID                 uuid.UUID
	UpdatedAt          pgtype.Timestamptz
	SendStatus         string
	SendingStartedAt   pgtype.Timestamptz
	SendingCompletedAt pgtype.Timestamptz
	EmailsSent         int32
}

func (q *Queries) UpdateNewsletterSendStatus(ctx context.Context, db DBTX, arg UpdateNewsletterSendStatusParams) (Newsletter, error) {
	row := db.QueryRow(ctx, updateNewsletterSendStatus,
		arg.ID,
		arg.UpdatedAt,
		arg.SendStatus,
		arg.SendingStartedAt,
		arg.SendingCompletedAt,
		arg.EmailsSent,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Slug,
		&i.Content,
		&i.SendStatus,
		&i.TotalRecipients,
		&i.EmailsSent,
		&i.SendingStartedAt,
		&i.SendingCompletedAt,
	)
	return i, err
}
