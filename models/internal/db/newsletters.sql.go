// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: newsletters.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsletters = `-- name: CountNewsletters :one
select count(*) from newsletters
`

// CountNewsletters
//
//	select count(*) from newsletters
func (q *Queries) CountNewsletters(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countNewsletters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteNewsletter = `-- name: DeleteNewsletter :exec
delete from newsletters where id=$1
`

// DeleteNewsletter
//
//	delete from newsletters where id=$1
func (q *Queries) DeleteNewsletter(ctx context.Context, db DBTX, id int32) error {
	_, err := db.Exec(ctx, deleteNewsletter, id)
	return err
}

const insertNewsletter = `-- name: InsertNewsletter :one
insert into
    newsletters (created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content)
values
    (now(), now(), $1, $2, $3, $4, $5, $6, $7)
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type InsertNewsletterParams struct {
	Title           string
	Slug            pgtype.Text
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Content         pgtype.Text
}

// InsertNewsletter
//
//	insert into
//	    newsletters (created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content)
//	values
//	    (now(), now(), $1, $2, $3, $4, $5, $6, $7)
//	returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
func (q *Queries) InsertNewsletter(ctx context.Context, db DBTX, arg InsertNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, insertNewsletter,
		arg.Title,
		arg.Slug,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletterByID = `-- name: QueryNewsletterByID :one
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters where id=$1
`

// QueryNewsletterByID
//
//	select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters where id=$1
func (q *Queries) QueryNewsletterByID(ctx context.Context, db DBTX, id int32) (Newsletter, error) {
	row := db.QueryRow(ctx, queryNewsletterByID, id)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletters = `-- name: QueryNewsletters :many
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
`

// QueryNewsletters
//
//	select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
func (q *Queries) QueryNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPaginatedNewsletters = `-- name: QueryPaginatedNewsletters :many
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedNewslettersParams struct {
	Offset int64
	Limit  int64
}

// QueryPaginatedNewsletters
//
//	select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
//	order by created_at desc
//	limit $2::bigint offset $1::bigint
func (q *Queries) QueryPaginatedNewsletters(ctx context.Context, db DBTX, arg QueryPaginatedNewslettersParams) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryPaginatedNewsletters, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPublishedNewsletters = `-- name: QueryPublishedNewsletters :many
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters where is_published=true order by released_at desc
`

// QueryPublishedNewsletters
//
//	select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters where is_published=true order by released_at desc
func (q *Queries) QueryPublishedNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryPublishedNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNewsletter = `-- name: UpdateNewsletter :one
update newsletters
    set updated_at=now(), title=$2, slug=$3, meta_title=$4, meta_description=$5, is_published=$6, released_at=$7, content=$8
where id = $1
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type UpdateNewsletterParams struct {
	ID              int32
	Title           string
	Slug            pgtype.Text
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Content         pgtype.Text
}

// UpdateNewsletter
//
//	update newsletters
//	    set updated_at=now(), title=$2, slug=$3, meta_title=$4, meta_description=$5, is_published=$6, released_at=$7, content=$8
//	where id = $1
//	returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
func (q *Queries) UpdateNewsletter(ctx context.Context, db DBTX, arg UpdateNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, updateNewsletter,
		arg.ID,
		arg.Title,
		arg.Slug,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const upsertNewsletter = `-- name: UpsertNewsletter :one
insert into
    newsletters (created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content)
values
    (now(), now(), $1, $2, $3, $4, $5, $6, $7)
on conflict (id) do update set updated_at=now(), title=excluded.title, slug=excluded.slug, meta_title=excluded.meta_title, meta_description=excluded.meta_description, is_published=excluded.is_published, released_at=excluded.released_at, content=excluded.content
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type UpsertNewsletterParams struct {
	Title           string
	Slug            pgtype.Text
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Content         pgtype.Text
}

// UpsertNewsletter
//
//	insert into
//	    newsletters (created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content)
//	values
//	    (now(), now(), $1, $2, $3, $4, $5, $6, $7)
//	on conflict (id) do update set updated_at=now(), title=excluded.title, slug=excluded.slug, meta_title=excluded.meta_title, meta_description=excluded.meta_description, is_published=excluded.is_published, released_at=excluded.released_at, content=excluded.content
//	returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
func (q *Queries) UpsertNewsletter(ctx context.Context, db DBTX, arg UpsertNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, upsertNewsletter,
		arg.Title,
		arg.Slug,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}
