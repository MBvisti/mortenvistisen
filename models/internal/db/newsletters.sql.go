// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: newsletters.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsletters = `-- name: CountNewsletters :one
select count(*) from newsletters
`

func (q *Queries) CountNewsletters(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countNewsletters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteNewsletter = `-- name: DeleteNewsletter :exec
delete from newsletters where id=$1
`

func (q *Queries) DeleteNewsletter(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteNewsletter, id)
	return err
}

const insertNewsletter = `-- name: InsertNewsletter :one
insert into
    newsletters (id, created_at, updated_at, title, meta_title, meta_description, is_published, released_at, slug, content)
values
    ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8)
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type InsertNewsletterParams struct {
	ID              uuid.UUID
	Title           string
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Slug            pgtype.Text
	Content         pgtype.Text
}

func (q *Queries) InsertNewsletter(ctx context.Context, db DBTX, arg InsertNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, insertNewsletter,
		arg.ID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Slug,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletterByID = `-- name: QueryNewsletterByID :one
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters where id=$1
`

func (q *Queries) QueryNewsletterByID(ctx context.Context, db DBTX, id uuid.UUID) (Newsletter, error) {
	row := db.QueryRow(ctx, queryNewsletterByID, id)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletters = `-- name: QueryNewsletters :many
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
`

func (q *Queries) QueryNewsletters(ctx context.Context, db DBTX) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryNewsletters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPaginatedNewsletters = `-- name: QueryPaginatedNewsletters :many
select id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content from newsletters
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedNewslettersParams struct {
	Offset int64
	Limit  int64
}

func (q *Queries) QueryPaginatedNewsletters(ctx context.Context, db DBTX, arg QueryPaginatedNewslettersParams) ([]Newsletter, error) {
	rows, err := db.Query(ctx, queryPaginatedNewsletters, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.IsPublished,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNewsletter = `-- name: UpdateNewsletter :one
update newsletters
    set updated_at=now(), title=$2, meta_title=$3, meta_description=$4, is_published=$5, released_at=$6, slug=$7, content=$8
where id = $1
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type UpdateNewsletterParams struct {
	ID              uuid.UUID
	Title           string
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Slug            pgtype.Text
	Content         pgtype.Text
}

func (q *Queries) UpdateNewsletter(ctx context.Context, db DBTX, arg UpdateNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, updateNewsletter,
		arg.ID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Slug,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const upsertNewsletter = `-- name: UpsertNewsletter :one
insert into
    newsletters (id, created_at, updated_at, title, meta_title, meta_description, is_published, released_at, slug, content)
values
    ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8)
on conflict (id) do update set updated_at=now(), title=excluded.title, meta_title=excluded.meta_title, meta_description=excluded.meta_description, is_published=excluded.is_published, released_at=excluded.released_at, slug=excluded.slug, content=excluded.content
returning id, created_at, updated_at, title, slug, meta_title, meta_description, is_published, released_at, content
`

type UpsertNewsletterParams struct {
	ID              uuid.UUID
	Title           string
	MetaTitle       string
	MetaDescription string
	IsPublished     pgtype.Bool
	ReleasedAt      pgtype.Timestamptz
	Slug            pgtype.Text
	Content         pgtype.Text
}

func (q *Queries) UpsertNewsletter(ctx context.Context, db DBTX, arg UpsertNewsletterParams) (Newsletter, error) {
	row := db.QueryRow(ctx, upsertNewsletter,
		arg.ID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.ReleasedAt,
		arg.Slug,
		arg.Content,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Slug,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}
