// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countArticles = `-- name: CountArticles :one
select count(*) from articles
`

// CountArticles
//
//	select count(*) from articles
func (q *Queries) CountArticles(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countArticles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteArticle = `-- name: DeleteArticle :exec
delete from articles where id=$1
`

// DeleteArticle
//
//	delete from articles where id=$1
func (q *Queries) DeleteArticle(ctx context.Context, db DBTX, id int32) error {
	_, err := db.Exec(ctx, deleteArticle, id)
	return err
}

const insertArticle = `-- name: InsertArticle :one
insert into
    articles (created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content)
values
    (now(), now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type InsertArticleParams struct {
	FirstPublishedAt pgtype.Timestamptz
	Published        bool
	Title            string
	Excerpt          pgtype.Text
	MetaTitle        pgtype.Text
	MetaDescription  pgtype.Text
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
}

// InsertArticle
//
//	insert into
//	    articles (created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content)
//	values
//	    (now(), now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
//	returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
func (q *Queries) InsertArticle(ctx context.Context, db DBTX, arg InsertArticleParams) (Article, error) {
	row := db.QueryRow(ctx, insertArticle,
		arg.FirstPublishedAt,
		arg.Published,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticleByID = `-- name: QueryArticleByID :one
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where id=$1
`

// QueryArticleByID
//
//	select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where id=$1
func (q *Queries) QueryArticleByID(ctx context.Context, db DBTX, id int32) (Article, error) {
	row := db.QueryRow(ctx, queryArticleByID, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticleBySlug = `-- name: QueryArticleBySlug :one
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where slug=$1
`

// QueryArticleBySlug
//
//	select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where slug=$1
func (q *Queries) QueryArticleBySlug(ctx context.Context, db DBTX, slug string) (Article, error) {
	row := db.QueryRow(ctx, queryArticleBySlug, slug)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticles = `-- name: QueryArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
`

// QueryArticles
//
//	select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
func (q *Queries) QueryArticles(ctx context.Context, db DBTX) ([]Article, error) {
	rows, err := db.Query(ctx, queryArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPaginatedArticles = `-- name: QueryPaginatedArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedArticlesParams struct {
	Offset int64
	Limit  int64
}

// QueryPaginatedArticles
//
//	select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
//	order by created_at desc
//	limit $2::bigint offset $1::bigint
func (q *Queries) QueryPaginatedArticles(ctx context.Context, db DBTX, arg QueryPaginatedArticlesParams) ([]Article, error) {
	rows, err := db.Query(ctx, queryPaginatedArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPublishedArticles = `-- name: QueryPublishedArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where published=true order by first_published_at desc
`

// QueryPublishedArticles
//
//	select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where published=true order by first_published_at desc
func (q *Queries) QueryPublishedArticles(ctx context.Context, db DBTX) ([]Article, error) {
	rows, err := db.Query(ctx, queryPublishedArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :one
update articles
    set updated_at=now(), first_published_at=$2, published=$3, title=$4, excerpt=$5, meta_title=$6, meta_description=$7, slug=$8, image_link=$9, read_time=$10, content=$11
where id = $1
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type UpdateArticleParams struct {
	ID               int32
	FirstPublishedAt pgtype.Timestamptz
	Published        bool
	Title            string
	Excerpt          pgtype.Text
	MetaTitle        pgtype.Text
	MetaDescription  pgtype.Text
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
}

// UpdateArticle
//
//	update articles
//	    set updated_at=now(), first_published_at=$2, published=$3, title=$4, excerpt=$5, meta_title=$6, meta_description=$7, slug=$8, image_link=$9, read_time=$10, content=$11
//	where id = $1
//	returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
func (q *Queries) UpdateArticle(ctx context.Context, db DBTX, arg UpdateArticleParams) (Article, error) {
	row := db.QueryRow(ctx, updateArticle,
		arg.ID,
		arg.FirstPublishedAt,
		arg.Published,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const upsertArticle = `-- name: UpsertArticle :one
insert into
    articles (created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content)
values
    (now(), now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
on conflict (id) do update set updated_at=now(), first_published_at=excluded.first_published_at, published=excluded.published, title=excluded.title, excerpt=excluded.excerpt, meta_title=excluded.meta_title, meta_description=excluded.meta_description, slug=excluded.slug, image_link=excluded.image_link, read_time=excluded.read_time, content=excluded.content
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type UpsertArticleParams struct {
	FirstPublishedAt pgtype.Timestamptz
	Published        bool
	Title            string
	Excerpt          pgtype.Text
	MetaTitle        pgtype.Text
	MetaDescription  pgtype.Text
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
}

// UpsertArticle
//
//	insert into
//	    articles (created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content)
//	values
//	    (now(), now(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
//	on conflict (id) do update set updated_at=now(), first_published_at=excluded.first_published_at, published=excluded.published, title=excluded.title, excerpt=excluded.excerpt, meta_title=excluded.meta_title, meta_description=excluded.meta_description, slug=excluded.slug, image_link=excluded.image_link, read_time=excluded.read_time, content=excluded.content
//	returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
func (q *Queries) UpsertArticle(ctx context.Context, db DBTX, arg UpsertArticleParams) (Article, error) {
	row := db.QueryRow(ctx, upsertArticle,
		arg.FirstPublishedAt,
		arg.Published,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}
