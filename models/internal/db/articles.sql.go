// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countArticles = `-- name: CountArticles :one
select count(*) from articles
`

func (q *Queries) CountArticles(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countArticles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteArticle = `-- name: DeleteArticle :exec
delete from articles where id=$1
`

func (q *Queries) DeleteArticle(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteArticle, id)
	return err
}

const insertArticle = `-- name: InsertArticle :one
insert into
    articles (id, created_at, updated_at, first_published_at, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content, published)
values
    ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type InsertArticleParams struct {
	ID               uuid.UUID
	FirstPublishedAt pgtype.Timestamptz
	Title            string
	Excerpt          string
	MetaTitle        string
	MetaDescription  string
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
	Published        bool
}

func (q *Queries) InsertArticle(ctx context.Context, db DBTX, arg InsertArticleParams) (Article, error) {
	row := db.QueryRow(ctx, insertArticle,
		arg.ID,
		arg.FirstPublishedAt,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
		arg.Published,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticleByID = `-- name: QueryArticleByID :one
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where id=$1
`

func (q *Queries) QueryArticleByID(ctx context.Context, db DBTX, id uuid.UUID) (Article, error) {
	row := db.QueryRow(ctx, queryArticleByID, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticleBySlug = `-- name: QueryArticleBySlug :one
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles where slug=$1
`

func (q *Queries) QueryArticleBySlug(ctx context.Context, db DBTX, slug string) (Article, error) {
	row := db.QueryRow(ctx, queryArticleBySlug, slug)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const queryArticles = `-- name: QueryArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
`

func (q *Queries) QueryArticles(ctx context.Context, db DBTX) ([]Article, error) {
	rows, err := db.Query(ctx, queryArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPaginatedArticles = `-- name: QueryPaginatedArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedArticlesParams struct {
	Offset int64
	Limit  int64
}

func (q *Queries) QueryPaginatedArticles(ctx context.Context, db DBTX, arg QueryPaginatedArticlesParams) ([]Article, error) {
	rows, err := db.Query(ctx, queryPaginatedArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPublishedArticles = `-- name: QueryPublishedArticles :many
select id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content from articles
where first_published_at is not null
order by first_published_at desc
`

func (q *Queries) QueryPublishedArticles(ctx context.Context, db DBTX) ([]Article, error) {
	rows, err := db.Query(ctx, queryPublishedArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstPublishedAt,
			&i.Published,
			&i.Title,
			&i.Excerpt,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.Slug,
			&i.ImageLink,
			&i.ReadTime,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArticle = `-- name: UpdateArticle :one
update articles
    set updated_at=now(), first_published_at=$2, title=$3, excerpt=$4, meta_title=$5, meta_description=$6, slug=$7, image_link=$8, read_time=$9, content=$10, published=$11
where id = $1
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type UpdateArticleParams struct {
	ID               uuid.UUID
	FirstPublishedAt pgtype.Timestamptz
	Title            string
	Excerpt          string
	MetaTitle        string
	MetaDescription  string
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
	Published        bool
}

func (q *Queries) UpdateArticle(ctx context.Context, db DBTX, arg UpdateArticleParams) (Article, error) {
	row := db.QueryRow(ctx, updateArticle,
		arg.ID,
		arg.FirstPublishedAt,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
		arg.Published,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}

const upsertArticle = `-- name: UpsertArticle :one
insert into
    articles (id, created_at, updated_at, first_published_at, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content, published)
values
    ($1, now(), now(), $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
on conflict (id) do update set updated_at=now(), first_published_at=excluded.first_published_at, title=excluded.title, excerpt=excluded.excerpt, meta_title=excluded.meta_title, meta_description=excluded.meta_description, slug=excluded.slug, image_link=excluded.image_link, read_time=excluded.read_time, content=excluded.content, published=excluded.published
returning id, created_at, updated_at, first_published_at, published, title, excerpt, meta_title, meta_description, slug, image_link, read_time, content
`

type UpsertArticleParams struct {
	ID               uuid.UUID
	FirstPublishedAt pgtype.Timestamptz
	Title            string
	Excerpt          string
	MetaTitle        string
	MetaDescription  string
	Slug             string
	ImageLink        pgtype.Text
	ReadTime         pgtype.Int4
	Content          pgtype.Text
	Published        bool
}

func (q *Queries) UpsertArticle(ctx context.Context, db DBTX, arg UpsertArticleParams) (Article, error) {
	row := db.QueryRow(ctx, upsertArticle,
		arg.ID,
		arg.FirstPublishedAt,
		arg.Title,
		arg.Excerpt,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.Slug,
		arg.ImageLink,
		arg.ReadTime,
		arg.Content,
		arg.Published,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstPublishedAt,
		&i.Published,
		&i.Title,
		&i.Excerpt,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Slug,
		&i.ImageLink,
		&i.ReadTime,
		&i.Content,
	)
	return i, err
}
