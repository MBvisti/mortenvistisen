// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProjects = `-- name: CountProjects :one
select count(*) from projects
`

// CountProjects
//
//	select count(*) from projects
func (q *Queries) CountProjects(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, countProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProject = `-- name: DeleteProject :exec
delete from projects where id=$1
`

// DeleteProject
//
//	delete from projects where id=$1
func (q *Queries) DeleteProject(ctx context.Context, db DBTX, id int32) error {
	_, err := db.Exec(ctx, deleteProject, id)
	return err
}

const insertProject = `-- name: InsertProject :one
insert into
    projects (
      created_at,
      updated_at,
      published,
      title,
      slug,
      started_at,
      status,
      description,
      content,
      project_url
    )
values
    (
      now(),
      now(),
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8
    )
returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
`

type InsertProjectParams struct {
	Published   bool
	Title       string
	Slug        string
	StartedAt   pgtype.Timestamptz
	Status      string
	Description string
	Content     string
	ProjectUrl  pgtype.Text
}

// InsertProject
//
//	insert into
//	    projects (
//	      created_at,
//	      updated_at,
//	      published,
//	      title,
//	      slug,
//	      started_at,
//	      status,
//	      description,
//	      content,
//	      project_url
//	    )
//	values
//	    (
//	      now(),
//	      now(),
//	      $1,
//	      $2,
//	      $3,
//	      $4,
//	      $5,
//	      $6,
//	      $7,
//	      $8
//	    )
//	returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
func (q *Queries) InsertProject(ctx context.Context, db DBTX, arg InsertProjectParams) (Project, error) {
	row := db.QueryRow(ctx, insertProject,
		arg.Published,
		arg.Title,
		arg.Slug,
		arg.StartedAt,
		arg.Status,
		arg.Description,
		arg.Content,
		arg.ProjectUrl,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.Title,
		&i.Slug,
		&i.StartedAt,
		&i.Status,
		&i.Description,
		&i.Content,
		&i.ProjectUrl,
	)
	return i, err
}

const queryPaginatedProjects = `-- name: QueryPaginatedProjects :many
select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects
order by created_at desc
limit $2::bigint offset $1::bigint
`

type QueryPaginatedProjectsParams struct {
	Offset int64
	Limit  int64
}

// QueryPaginatedProjects
//
//	select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects
//	order by created_at desc
//	limit $2::bigint offset $1::bigint
func (q *Queries) QueryPaginatedProjects(ctx context.Context, db DBTX, arg QueryPaginatedProjectsParams) ([]Project, error) {
	rows, err := db.Query(ctx, queryPaginatedProjects, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
			&i.Title,
			&i.Slug,
			&i.StartedAt,
			&i.Status,
			&i.Description,
			&i.Content,
			&i.ProjectUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryProjectByID = `-- name: QueryProjectByID :one
select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where id=$1
`

// QueryProjectByID
//
//	select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where id=$1
func (q *Queries) QueryProjectByID(ctx context.Context, db DBTX, id int32) (Project, error) {
	row := db.QueryRow(ctx, queryProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.Title,
		&i.Slug,
		&i.StartedAt,
		&i.Status,
		&i.Description,
		&i.Content,
		&i.ProjectUrl,
	)
	return i, err
}

const queryProjectBySlug = `-- name: QueryProjectBySlug :one
select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where slug=$1
`

// QueryProjectBySlug
//
//	select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where slug=$1
func (q *Queries) QueryProjectBySlug(ctx context.Context, db DBTX, slug string) (Project, error) {
	row := db.QueryRow(ctx, queryProjectBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.Title,
		&i.Slug,
		&i.StartedAt,
		&i.Status,
		&i.Description,
		&i.Content,
		&i.ProjectUrl,
	)
	return i, err
}

const queryProjects = `-- name: QueryProjects :many
select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects
`

// QueryProjects
//
//	select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects
func (q *Queries) QueryProjects(ctx context.Context, db DBTX) ([]Project, error) {
	rows, err := db.Query(ctx, queryProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
			&i.Title,
			&i.Slug,
			&i.StartedAt,
			&i.Status,
			&i.Description,
			&i.Content,
			&i.ProjectUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPublishedProjects = `-- name: QueryPublishedProjects :many
select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where published=true order by started_at desc
`

// QueryPublishedProjects
//
//	select id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url from projects where published=true order by started_at desc
func (q *Queries) QueryPublishedProjects(ctx context.Context, db DBTX) ([]Project, error) {
	rows, err := db.Query(ctx, queryPublishedProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
			&i.Title,
			&i.Slug,
			&i.StartedAt,
			&i.Status,
			&i.Description,
			&i.Content,
			&i.ProjectUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
update projects
set
    updated_at=now(),
    published=$2,
    title=$3,
    slug=$4,
    started_at=$5,
    status=$6,
    description=$7,
    content=$8,
    project_url=$9
where id = $1
returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
`

type UpdateProjectParams struct {
	ID          int32
	Published   bool
	Title       string
	Slug        string
	StartedAt   pgtype.Timestamptz
	Status      string
	Description string
	Content     string
	ProjectUrl  pgtype.Text
}

// UpdateProject
//
//	update projects
//	set
//	    updated_at=now(),
//	    published=$2,
//	    title=$3,
//	    slug=$4,
//	    started_at=$5,
//	    status=$6,
//	    description=$7,
//	    content=$8,
//	    project_url=$9
//	where id = $1
//	returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
func (q *Queries) UpdateProject(ctx context.Context, db DBTX, arg UpdateProjectParams) (Project, error) {
	row := db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Published,
		arg.Title,
		arg.Slug,
		arg.StartedAt,
		arg.Status,
		arg.Description,
		arg.Content,
		arg.ProjectUrl,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.Title,
		&i.Slug,
		&i.StartedAt,
		&i.Status,
		&i.Description,
		&i.Content,
		&i.ProjectUrl,
	)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
insert into
    projects (
      created_at,
      updated_at,
      published,
      title,
      slug,
      started_at,
      status,
      description,
      content,
      project_url
    )
values
    (
      now(),
      now(),
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8
    )
on conflict (slug) do update
set
    updated_at=now(),
    published=excluded.published,
    title=excluded.title,
    started_at=excluded.started_at,
    status=excluded.status,
    description=excluded.description,
    content=excluded.content,
    project_url=excluded.project_url
returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
`

type UpsertProjectParams struct {
	Published   bool
	Title       string
	Slug        string
	StartedAt   pgtype.Timestamptz
	Status      string
	Description string
	Content     string
	ProjectUrl  pgtype.Text
}

// UpsertProject
//
//	insert into
//	    projects (
//	      created_at,
//	      updated_at,
//	      published,
//	      title,
//	      slug,
//	      started_at,
//	      status,
//	      description,
//	      content,
//	      project_url
//	    )
//	values
//	    (
//	      now(),
//	      now(),
//	      $1,
//	      $2,
//	      $3,
//	      $4,
//	      $5,
//	      $6,
//	      $7,
//	      $8
//	    )
//	on conflict (slug) do update
//	set
//	    updated_at=now(),
//	    published=excluded.published,
//	    title=excluded.title,
//	    started_at=excluded.started_at,
//	    status=excluded.status,
//	    description=excluded.description,
//	    content=excluded.content,
//	    project_url=excluded.project_url
//	returning id, created_at, updated_at, published, title, slug, started_at, status, description, content, project_url
func (q *Queries) UpsertProject(ctx context.Context, db DBTX, arg UpsertProjectParams) (Project, error) {
	row := db.QueryRow(ctx, upsertProject,
		arg.Published,
		arg.Title,
		arg.Slug,
		arg.StartedAt,
		arg.Status,
		arg.Description,
		arg.Content,
		arg.ProjectUrl,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.Title,
		&i.Slug,
		&i.StartedAt,
		&i.Status,
		&i.Description,
		&i.Content,
		&i.ProjectUrl,
	)
	return i, err
}
