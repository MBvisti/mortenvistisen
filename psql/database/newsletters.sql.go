// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: newsletters.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countNewsletters = `-- name: CountNewsletters :one
select count(id)
from newsletters
`

func (q *Queries) CountNewsletters(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countNewsletters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReleasedNewsletters = `-- name: CountReleasedNewsletters :one
select count(id)
from newsletters
where released=true
`

func (q *Queries) CountReleasedNewsletters(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countReleasedNewsletters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertNewsletter = `-- name: InsertNewsletter :one
insert into newsletters
	(id, created_at, updated_at, title, content, released, released_at)
values 
	($1, $2, $3, $4, $5, $6, $7)
returning id, created_at, updated_at, title, released, released_at, content
`

type InsertNewsletterParams struct {
	ID         uuid.UUID
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	Title      string
	Content    string
	Released   pgtype.Bool
	ReleasedAt pgtype.Timestamptz
}

func (q *Queries) InsertNewsletter(ctx context.Context, arg InsertNewsletterParams) (Newsletter, error) {
	row := q.db.QueryRow(ctx, insertNewsletter,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Title,
		arg.Content,
		arg.Released,
		arg.ReleasedAt,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Released,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletterByID = `-- name: QueryNewsletterByID :one
select id, created_at, updated_at, title, released, released_at, content
from newsletters
where id = $1
`

func (q *Queries) QueryNewsletterByID(ctx context.Context, id uuid.UUID) (Newsletter, error) {
	row := q.db.QueryRow(ctx, queryNewsletterByID, id)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Released,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}

const queryNewsletterInPages = `-- name: QueryNewsletterInPages :many
select newsletters.id, newsletters.created_at, newsletters.updated_at, newsletters.title, newsletters.released, newsletters.released_at, newsletters.content
from newsletters
limit 7
offset $1
`

func (q *Queries) QueryNewsletterInPages(ctx context.Context, offset int32) ([]Newsletter, error) {
	rows, err := q.db.Query(ctx, queryNewsletterInPages, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Newsletter
	for rows.Next() {
		var i Newsletter
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Released,
			&i.ReleasedAt,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewsletters = `-- name: QueryNewsletters :many
select
    newsletters.id as newsletter_id,
    newsletters.created_at as newsletter_created_at,
    newsletters.updated_at as newsletter_updated_at,
    newsletters.title as newsletter_title,
    newsletters.content as newsletter_content,
    newsletters.released as newsletter_released,
    newsletters.released_at as newsletter_released_at
from newsletters
where
    (
        newsletters.released = $1::bool
        or $1::bool is null
    )
limit coalesce($3::int, null)
offset coalesce($2::int, 0)
`

type QueryNewslettersParams struct {
	IsReleased pgtype.Bool
	Offset     sql.NullInt32
	Limit      sql.NullInt32
}

type QueryNewslettersRow struct {
	NewsletterID         uuid.UUID
	NewsletterCreatedAt  pgtype.Timestamptz
	NewsletterUpdatedAt  pgtype.Timestamptz
	NewsletterTitle      string
	NewsletterContent    string
	NewsletterReleased   pgtype.Bool
	NewsletterReleasedAt pgtype.Timestamptz
}

func (q *Queries) QueryNewsletters(ctx context.Context, arg QueryNewslettersParams) ([]QueryNewslettersRow, error) {
	rows, err := q.db.Query(ctx, queryNewsletters, arg.IsReleased, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryNewslettersRow
	for rows.Next() {
		var i QueryNewslettersRow
		if err := rows.Scan(
			&i.NewsletterID,
			&i.NewsletterCreatedAt,
			&i.NewsletterUpdatedAt,
			&i.NewsletterTitle,
			&i.NewsletterContent,
			&i.NewsletterReleased,
			&i.NewsletterReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryNewslettersCount = `-- name: QueryNewslettersCount :one
select count(id)
from newsletters
`

func (q *Queries) QueryNewslettersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, queryNewslettersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const queryReleasedNewslettersCount = `-- name: QueryReleasedNewslettersCount :one
select count(id) as newsletters_count
from newsletters
where released = true
`

func (q *Queries) QueryReleasedNewslettersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, queryReleasedNewslettersCount)
	var newsletters_count int64
	err := row.Scan(&newsletters_count)
	return newsletters_count, err
}

const updateNewsletter = `-- name: UpdateNewsletter :one
update newsletters
	set updated_at = $1, title = $2, content = $3, released = $4, released_at = $5
where id = $6
returning id, created_at, updated_at, title, released, released_at, content
`

type UpdateNewsletterParams struct {
	UpdatedAt  pgtype.Timestamptz
	Title      string
	Content    string
	Released   pgtype.Bool
	ReleasedAt pgtype.Timestamptz
	ID         uuid.UUID
}

func (q *Queries) UpdateNewsletter(ctx context.Context, arg UpdateNewsletterParams) (Newsletter, error) {
	row := q.db.QueryRow(ctx, updateNewsletter,
		arg.UpdatedAt,
		arg.Title,
		arg.Content,
		arg.Released,
		arg.ReleasedAt,
		arg.ID,
	)
	var i Newsletter
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Released,
		&i.ReleasedAt,
		&i.Content,
	)
	return i, err
}
